*) @RestController
- Dùng để thay thế cho @Controller:
    + @Controller dùng để prepare Model và chọn view để hiện thị data.
    + Khi chỉ gọi anotation @Controller thì view sẽ hiện thị toàn bộ data.
    + Vì còn có nhiệm vụ là ghi dữ liệu trực tiếp vào luồng response -> @ResponseBody
    -> Lúc này kết quả sẽ trả về đúng cái mình return (JSON, XML, ....).
   => Từ đây, @RestController ra đời.
- Dùng để thuận tiện trong việc phát triển các dự án RESTful Web Service.
*) Các loại HTTP Request
- Các hành động CRUD:
    + Create: POST -> @PostMapping
    + Read: GET -> @GetMapping
    + Update: PUT -> @PutMapping
    + Delete: DELETE -> @DeleteMapping
    + @RequestMapping: Chỉ định endpoint bắt buộc. Được dùng ở bên trên class Controller.
- Nhận request:
    + Request param:
        ->  Ví dụ: GET /users?age=18&name=Khương
            Mình có 2 request param là age và name
            =>  @GetMapping("/users")
                public ResponseEntity<?> getAllUsers(
                    @RequestParam("age") int age,
                    @RequestParam("name") string name
                ){}
            Nếu 2 param là optional thì phải viết:
                @RequestParam(value = "age", required = false) Integer age
        -> Request param còn có defaultValue.
    + Path variable:
        -> Là một phần trong url. Cách dùng:
            @GetMapping("/users/{id}/info")
            public ResponseEntity<?> getUserInfo(
                @PathVariable(value = "id", defaultValue = "0") int userId
            ){}
        -> Có các thuộc tính như @RequestParam.
    + Request body:
        -> Cần dùng khi sử dụng @PostMapping hay @PutMapping
        -> Đây là nơi chứa data chính để gửi lên. Thường ở dạng JSON, class Controller sẽ tự động
        map về Object (thường là DTO (Data Transfer Object))
        -> Ví dụ:
            @GetMapping("/users")
            public ResponseEntity<?>(@RequestBody UserDTO userDto){}
    + Header
- ResponseEntity<T>:
    -> Ưu điểm: Không code dài dòng, tự builder, giải quyết trả về status.
    -> Return về dạng ResponseEntity.ok() / .notFound()
- @ModelAttribute: Đánh dấu một model được gửi lên từ form.
*) Các loại DATA
    + DTO (Data Transfer Object):
        -> Là các class đóng gói để tách biệt giữa response/request với entity. Được dùng để trao đổi
        thông tin từ phía Client-Sever hoặc giữa các Service trong MicroService. Mục đích là để giảm
        bớt lượng info gửi đi.
        -> Dùng phổ biến ở Web Layer.
    + Domain model:
        -> Là class đảm nhiệm làm các class tham số đầu vào để tính toán hoặc là kết quả tính toán.
    + Entity:
        -> Là các class thao tác trực tiếp từ DB và dùng để Map sang DB.
        -> Dùng phổ biến ở Repository Layer
- Model Mapping: Là việc chuyển dữ liệu từ các dạng DATA với nhau.
*) Dependency Injection:
- Module Coupling: Luôn đưa mqh giữa các module về dạng Loose Coupling
- Nguyên lý Dependency Inversion:
    + Ý thứ 5 của SOLID: DI principle (Dependecy Inversion Principle)
        -> Các module cấp cao không được phụ thuộc trực tiếp vào các module cấp thấp. Cả 2 nên phụ thuộc
        vào abstraction (thường là interface).
            => Bằng các lợi dụng tính đa hình, chúng ta nên để các class phụ thuộc vào abstraction.
        -> Abstraction không nên phụ thuộc vào chi tiết, và ngược lại.
- IoC (Inversion of Control):
    -> IoC nhằm mục đích đơn giản hóa quá trình tạo đối tượng và liên kết giữa chúng, bằng cách tuân
    theo nguyên tắc: Không tạo đối tượng, chỉ mô tả cách chúng sẽ được tạo ra.
    -> IoC sẽ quản lý, phân tích các mối phụ thuộc, tạo các đối tượng theo thứ tự hợp lý và liên kết
    chúng lại theo mô tả của lập trình viên.
    -> Cách dùng: Đánh dấu một class là module bằng annotation @Component/@Service/@Repository/..., sau đó
    dùng @Autowired để tìm object tương ứng và inject (chèn) nó vào. (Thứ tự ưu tiên: Type -> Name ->
    @Primary/@Qualifier)
    -> IoC Container: ApplicationContext
    -> Các module trong IoC Container: Bean
- Dependency Injection sẽ thực hiện:
    + Tìm và inject Bean tương ứng (@Autowired).
    + Tạo tiếp module cấp cao, IoC sẽ tìm module cấp thấp mà module đó phụ thuộc và inject vào module
    cấp cao đó.
    -> Khi run dự án, IoC sẽ quét tất cả class được đánh dấu là Bean, tạo một đối tượng duy nhất (Singleton)
    và bỏ vào IoC Container, lúc nào cần sẽ lấy ra sử dụng. Do đó, các module được đảm bảo IoC chỉ tạo ra
    một object duy nhất.
    -> Nếu khi tạo Bean mới, mà Bean đó cần phụ thuộc vào Bean khác, IoC sẽ tìm kiếm để inject
    vào. Nếu Bean đó chưa có thì tạo mới, sau đó inject vào. Việc inject tự động này dược gọi là
    Dependency Injection.
- Các loại Injection:
    + Constructor-based Injection: inject các module bắt buộc, các module được inject nằm trong constructor.
    + Setter-based Injection: inject các module tùy chọn. Mỗi module sẽ được inject thông qua setter.
*) Bean và ApplicationContext
- Bean: là những module chính của chương trình được IoC Container quản lý. Có thể phụ thuộc lẫn nhau.
- Application Context: là khái niệm để chỉ IoC Container. Tương tự BeanFactory nhưng ở mức cao hơn.
- Inject Bean vào Bean khác:
    + @Autowired: Sẽ tự động tìm và inject Bean phù hợp.
    + Thông qua constructor hoặc setter:
        -> Gọi constructor truyền trực tiếp không cần annotation.
        -> Dùng phương thức set để inject (thêm annotation @Required để setter luôn được gọi để inject).
        -> Cách dùng setter để inject thường dùng trong trường hợp phụ thuộc vòng. Spring Boot sẽ không biết
        nên khởi tạo constructor nào trước. Nên một Bean sẽ dùng constructor và một Bean dùng setter.
    + Khi có nhiều Bean phù hợp và Spring Boot không biết chọn Bean nào:
        -> Dùng annotation @Primary: Chỉ định thứ tự ưu tiên của Bean.
        -> Dùng annotation @Qualifier: Chỉ định rõ tên Bean (Tên class). Đặt trước tên field.
- Bean Life Cycle (Vòng đời của Bean):
    + IoC Container tạo Bean.
    + Gọi các setter method để inject các Bean.
    + @PostConstructor được gọi.
    + Init method được gọi.
    + Sau khi không dùng nữa sẽ được hủy thông qua việc gọi @PreDestroy
    -> @PostConstructor: là sau khi Bean đã khởi tạo xong. Dùng để thực hiện một số task khi khởi tạo Bean.
    -> @PreDestroy: là trước khi Bean bị phá hủy. Thực hiện task để dọn dẹp Bean trước khi phá hủy.
    -> Dùng 2 annotation này để đánh dấu lên method, method đó sẽ tự động gọi khi sự kiện Bean xảy ra.
- Các loại Bean (Scope):
    + Singleton (mặc định): IoC Container chỉ tạo đúng duy nhất 1 object từ class Bean này.
    + Prototype: return một Bean object riêng biệt cho mỗi lần sử dụng. (@Scope("prototype"))
    + Request: tạo mỗi Bean cho mỗi request.
    + Session: tạo mỗi Bean cho mỗi session.
    + Global Session: tạo mỗi Bean cho mỗi global session.
- Dùng @Bean bên trong @Configuration
    + Cách này dùng cho trường hợp Bean cần thực hiện nhiều thao tác phức tạp để khởi tạo, hoặc có nhiều
    Bean liên quan tới nhau.
    + Do đó thay vì khởi tạo riêng lẻ thì gom chung các Bean cần khởi tạo lại bỏ vào class chứa. Thường
    các class được đánh dấu là @Configuration và có hậu tố là Config.
    + Các thao tác xử lý được đặt trong Constructor và khai báo các module bằng @Bean
*) ModelMapper
- Là một thư viện của Java, giúp đơn giản hóa việc convert giữa các Class.
- Ví dụ: Thay vì phải copy từng field của class A sang class B thì làm như sau:
    // Object nguồn
    User user = new User("john", "123456", "Nguyễn Văn John", 20);

    // Tạo mapper object
    ModelMapper mapper = new ModelMapper();

    // Map thành object đích
    UserDto userDto = mapper.map(user, UserDto.class);
- Trước khi sử dụng thì nên cấu hình cho nó, lý tưởng là biến thành Bean và inject tự động:
    @Configuration
    public class ModelMapperConfig {
        @Bean
        public ModelMapper modelMapper() {
            // Tạo object và cấu hình
            ModelMapper modelMapper = new ModelMapper();
            modelMapper.getConfiguration()
                    .setMatchingStrategy(MatchingStrategies.STRICT); // Map chặt chẽ
            return modelMapper;
        }
    }
- Lưu ý luôn test và để ý xem đã map đúng chưa!
*) @ControllerAdvice và @ExceptionHandler
- AOP (Aspect Oriented Programming): ngắt ngang một method để thực hiện method khác, trong điều kiện gì đó.
- @ExceptionHandler: cho phép xử lý exception trong một controller cụ thể. Khi một exception được ném ra,
hàm đánh dấu với annotation sẽ được gọi.
    Ví dụ:
        @GetMapping("/users/{id}")
        public User getUser(@PathVariable Long id) {
            if (id <= 0) {
                throw new IllegalArgumentException("ID không hợp lệ!");
            }
            // Giả sử đây là logic tìm user
            return new User(id, "John Doe");
        }

        @ExceptionHandler(IllegalArgumentException.class)
        public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException ex) {
            return new ResponseEntity<>("Lỗi: " + ex.getMessage(), HttpStatus.BAD_REQUEST);
        }

- @ControllerAdvice/@RestControllerAdvice: Xử lý exception toàn cục.
    Ví dụ:
    @RestControllerAdvice
    public class GlobalExceptionHandler {

        // Xử lý ngoại lệ ResourceNotFoundException
        @ExceptionHandler(ResourceNotFoundException.class)
        public ResponseEntity<String> handleResourceNotFound(ResourceNotFoundException ex) {
            return new ResponseEntity<>("Không tìm thấy tài nguyên: " + ex.getMessage(), HttpStatus.NOT_FOUND);
        }

        // Xử lý IllegalArgumentException hoặc các lỗi không hợp lệ
        @ExceptionHandler(IllegalArgumentException.class)
        public ResponseEntity<String> handleIllegalArgument(IllegalArgumentException ex) {
            return new ResponseEntity<>("Dữ liệu không hợp lệ: " + ex.getMessage(), HttpStatus.BAD_REQUEST);
        }

        // Xử lý lỗi chung bất ngờ (Global Exception)
        @ExceptionHandler(Exception.class)
        public ResponseEntity<String> handleGlobalException(Exception ex) {
            return new ResponseEntity<>("Đã xảy ra lỗi: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }

        // Xử lý lỗi valid data
        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
            Map<String, String> errors = new HashMap<>();
            ex.getBindingResult().getFieldErrors().forEach(error -> {
                errors.put(error.getField(), error.getDefaultMessage());
            });

            return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
        }
    }
- Có thể tự custom exception để xử lý các lỗi do logic gây ra.
- Thường sẽ trả về dạng JSON thay vì chuỗi (ErrorResponse)
*) Validation
- Thêm các annotation ràng buộc trên field : @NotNull, @NotEmpty, @Email, @Size,....
- Có thể thêm message sau đó: @NotNull(message = "Thiếu...")
- Sau đó trước mỗi param cần valid, thêm annotation @Valid/@Validated
- Cách xử lý validation fail:
    + Dùng tham số cuối cùng là BindingResult.
    + Bắt exception.
    C1:
    @PostMapping("/")
        public User createUser(
                @RequestBody @Valid UserDto userDto,
                BindingResult bindingResult) {  // Thêm tham số này
            // Khi có BindingResult thì lỗi được tạm bỏ qua để xử lý thủ công
            // Nếu có lỗi thì chặn lại
            if (bindingResult.hasErrors())
                throw new Exception("...");
            ...
        }
    C2:
    @ExceptionHandler(BindException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)  // Nếu validate fail thì trả về 400
    public String handleBindException(BindException e) {
        // Trả về message của lỗi đầu tiên
        String errorMessage = "Request không hợp lệ";
        if (e.getBindingResult().hasErrors())
            e.getBindingResult().getAllErrors().get(0).getDefaultMessage();
        return errorMessage;
    }
*) Sử dụng Thymeleaf để chạy web
- Thymeleaf là một Java Template Engine có nhiệm vụ xử lý và generate ra các file HTML, XML,..
- Cú pháp: Sẽ bắt đầu bằng chữ th:
    + ${...} : Dùng để lấy value(text) theo key truyền vào.
    Ví dụ:
        ("today", "Monday") -> "today" là key, "Monday" là value.
        -> <p>Today is: <span th:text="${today}"></span>.</p>
    + *{...} : Dùng để lấy giá trị của một biến cho trước bởi th:object
    Ví dụ:
        -> Thay vì <p>Name: <span th:text="${session.user.firstName}"></span>.</p>
        => <div th:object="${session.user}">
               <p>Name: <span th:text="*{firstName}"></span>.</p>
           </div>
    + @{...} : Xử lý và trả ra url theo context của máy chủ cho chúng ta.
    Ví dụ:
        <a href="#" th:href="@{/v1/about}">Link to About me</a>
        -> Có 2 loại đường dẫn là tuyệt đối (trước path có /) và tương đối. Tuyệt đối sẽ được dẫn từ
        8080/... Còn tương đối sẽ chèn tiếp tục sau url hiện tại. Ví dụ: ...8080/home thì nếu là @{about}
        thì sẽ thành .../8080/about.
*) Spring Boot JPA
- Là một phần trong hệ sinh thái Spring Data, nó tạo một layer giữa tầng service và database.
- Giúp ta thao tác với database dễ hơn, tự động config, code gọn hơn.
- Trong Spring Boot, Hibernate là impl, JPA là API tiêu chuẩn.
- Cách dùng:
    + Khởi tạo một interface repository và đánh dấu Bean, extend JpaRepository<T, Long>
    + Inject interface vào dự án và gọi các impl để dùng.



